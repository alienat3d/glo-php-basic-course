<?php
// В PHP выделяют две категории данных простые и сложные
// == Простые типы данных ==
$text = 'Glo Academy'; // строчные

echo gettype($text); // с помощью "gettype" можно вывести тип данных, содержания переменной "text"
echo "<br>";

$number = 456; // числовые

echo gettype($number);
echo "<br>";

$num = 4.56; // "double" или ("float"), числовые с дробным значением

echo gettype($num);
echo "<br>";

$boolean = true; // булево значение (либо true, либо false)

echo gettype($boolean);
echo "<br>";

// ? В PHP считается false значение 0, пустая строка, пустой массив, а также пустые переменные

// Для проверки является ли значение переменной ложью "false" можно применить следующий метод:
var_dump((bool) $text);
echo "<br>";

// ? Есть ещё тип данных "NULL", который говорит о том, что: либо такой переменной нет в принципе, либо она есть, но ей не присвоено никакое значение.

// Шестым простым типом данных в PHP является "ресурс", который представляет собой ссылку на внешний источник, напр. на соединение с БД.

// == Сложные типы данных ==
// Объекты это базовое понятие ООП, ключевой темы в PHP. Объект - это экземпляр того или иного шаблона\класса. И в целях простого знакомства с синтаксисом ООП создадим класс ForTest, а также объект этого класса objectTest.
class ForTest {}
$objectTest = new ForTest();

echo gettype($boolean) . "<br>";

// Массив — это "коробка с коробками". Или переменная со множеством значений. При помощи специального метода "array" мы сообщим системе, что создаётся массив.
$fruits = array("Apple", "Banana", "Orange");
$fruits = ["Apple", "Banana", "Orange"]; // альт. и более распространённый синтаксис создания массива

echo gettype($fruits) . "<br>";

// В PHP есть два типа массивов "простые" и "ассоциативные". Вверху мы уже рассмотрели "простой" массив.
// Чтобы обратиться к конкретному элементу простого массива надо использовать его индекс (порядковый номер в массиве, начиная с 0). Например, если нам нужен элемент "Apple":
echo $fruits[0] . "<br>";

// Если нам нужно добавить элемент в массив, то можно это сделать так: обратимся к массиву, напишем индекс нового элемента и присвоим значение.
$fruits[3] = 'Pineapple';

// Чтобы вывести содержимое массива на экран недостаточно просто использовать "echo", как мы делали раньше. Для этого случая используем методы "var_dump" или "print_r".
var_dump($fruits) . "<br>";
print_r($fruits) . "<br>"; // даёт то же самое, что и "var_dump", но в более сокращённом варианте

// "Ассоциативные массивы" — это такие массивы, у которых каждый элемент состоит из пары "ключ-значение".
$arr = ['dog'=>'Rex', 'cat'=>'Tom'];
echo "<br>";

// К элементам такого массива мы не можем обращаться через индекс, как в случае с простыми, а обращаемся мы к ним по названию ключа.
echo $arr['cat'] . '<br>';

// Массивы также бывают много мерными, т.е. содержать другие массивы.
$arrayWithArrays = [
  ['Al', 'Katie'],
  [38, 39]
];

// Чтобы забрать значение первого элемента второго вложенного массива, пропишем:
echo $arrayWithArrays[1][0] . '<br>'; // 38

// Или, чтобы забрать значение второго элемента первого вложенного массива:
echo $arrayWithArrays[0][1] . '<br>'; // 'Katie'

// == Условия ==
// Итак, представим, что у нас задача выводить на экран приветствие только в том случае, если переменная "name" существует и не null.
$name = '';

// if ($name == true) может быть сокращена до:
// А если, в противном случае, мы хотим выводить что-то иное, то используем "else"
// Если же у нас больше двух условий, то можем использовать "else if" столько раз, сколько нужно
if ($name == "Лёша") {
  echo "Добрый день, Лёша!";
} else if ($name == 'Катя') {
  echo "Добрый день, Катя!";
} else {
  echo 'Добрый день, пользователь!';
}

// Если у нас простое условие, то мы можем его сильно сократить при помощи тернарного оператора. В этом примере мы присвоим переменной текст либо одну строку, либо другую, в зависимости от значения переменной $age:
echo '<br>';

$age = 25;
$person = $age > 60 ? 'пожилой' : 'молодой';
echo "По противоположной стороне улицы шёл $person человек." . '<br>';

// Альтернативной условной конструкцией также является "switch case". Здесь система пробежится по каждому случаю ("case") и сравнит его предполагаемое значение с фактическим в переменной "anotherNum" и если оно совпадёт, то остановится (благодаря ключ. слову "break"), а если нет, то продолжит до конца. В конце обычно пишут "default" (но не обязательно), который будет делать что-то, если ни одного совпадения не найдено.
$anotherNum = 1;

switch ($anotherNum) {
  case 1:
    echo 'anotherNum равен 1';
    break;
  case 2:
    echo 'anotherNum равен 2';
    break;
  case 3:
    echo 'anotherNum равен 3';
    break;
  default:
    echo 'anotherNum > 3';
    break;
}

echo '<br>';

// == Циклы ==
// ? Циклы позволяют выполнять какое-то кол-во раз какие-то действия. Каждый проход цикла называют итерацией. В PHP существует 3 вида циклов + 1 специальный, созданный для перебора массивов: while, do while, for и foreach.

// Цикл "while" с предусловием:
$a = 10;

// В условии "while" сделаем условие, при соблюдении которого продолжается действие.
while ($a < 15) {
  echo ++$a . '<br>';
}

// Ещё есть цикл "do while" с постусловием, он очень похожа на "while", но делает проверку после выполнения действия, а не перед ним.
$b = 30;


echo '<br>';

do {
  echo --$b . '<br>'; // Даже, несмотря на то, что 29 не больше 30, мы всё равно сперва увидим результат выполнения, т.к. условие сработает после.
} while ($b > 30);

echo '<br>';

// Наиболее популярным является цикл "for", где в условии задаётся переменная со значением, с которого начинается цикл, затем условие, при котором он будет продолжаться и инкремент этой переменной.
// ? В случаях, когда необходимо прервать выполнение цикла или перейти к следующей итерации используются ключ. слова "break" & "continue". Например, при условии $i == 3 мы хотим остановить выполнение цикла.
$c = 1;

for ($i = 0; $i <= 10; $i++) {
  if ($i == 3) {
    break;
//    continue; // если мы применим "continue" то итерация с этим условием, т.е. 4-ая будет пропущена, а все остальные выполнятся как обычно
  }
  echo ++$c . '<br>';
}

echo '<br>';

// Цикл перебора массивов "foreach"
$array = [1, 'b', 3];

// Обратимся к каждому элементу массива поместив его в переменную (после "as") и выведем его на экран. Мы можем также вывести не только значение, но и его ключ, в данном случае индекс, если запишем $key=>$value
foreach ($array as $key=>$value) {
  echo $key . ') ' . $value . '<br>';
}

echo '<br>';

// Ну, или сделаем то же с ассоциативным массивом:
$team = ['Admin'=>'James', 'Frontend dev'=>'Al', 'Backend dev'=>'Anton', 'Designer'=>'Eugene'];

foreach ($team as $key=>$value) {
  echo $value . " ($key)" . '<br>';
}

echo '<br>';

// == Функции ==
// ? Функция — это блок кода, который определяется один раз, но может вызываться сколько угодно раз. Записывается при помощи ключ. слова "function", а вызываться может как до, так и после её объявления.

greeting('Алексей');

function greeting($name)
{
  echo "Приветствую тебя, $name!<br>";
}

greeting('Катерина');

// А теперь запишем функцию чуть посложнее, которая будет складывать два любых числа, помещённые в неё с помощью параметров.
// Если подставим значения по умолчанию (для $a — 1 и для $b — 2), то они будут подставляться всякий раз, если при вызове функции значения аргументов не указаны.

function sum($a = 1, $b = 2)
{
  return $a + $b; // Для того чтобы функция возвращала значение, которое можно будет использовать в другой части кода используем ключ. слово "return"
}

echo sum(5, 6) . '<br>';
echo sum(15, 22) . '<br>';
echo sum(155, 272) . '<br>';
echo sum() . '<br>';